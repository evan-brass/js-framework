<!DOCTYPE html>
<html>
<head>
	<title>Tests for: js-min</title>
	<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
	<style>
		.template, .instance {
			border: black 1px solid;
			padding: 1em;
			margin: 1em;
		}
		.instance {
			border-color: #eee;
		}
	</style>
	<h1>These are tests for my JavaScript Framework</h1>
	<p>You can find out more about it at <a href="https://github.com/evan-brass/js-framework">https://github.com/evan-brass/js-framework</a> or view the code that generates these examples here: <a href="https://github.com/evan-brass/js-framework/blob/master/test.html">https://github.com/evan-brass/js-framework/blob/master/test.html</a></p>
	<script type="module">
		import LiveData from './src/lib/live-data.mjs';
		import on from './src/users/on.mjs';
		import ref from './src/users/ref.mjs';
		import constant from './src/users/constant.mjs';
		import css from './src/users/css.mjs';
		import mount from './src/mount.mjs';
		import html from './src/html.mjs';
		import delay from './src/lib/delay.mjs';
		import dial from './src/tests/dial.mjs';
		import NodeArray from './src/users/node-array.mjs';
		const tests = [
			(function() {
				let inputEl;
				function makeLi(contents) {
					return html`<li>${contents}</li>`;
					// return `${contents}\n`;
				}
				const listItems = new NodeArray(
					['test 1', 'test 2', 'test 3'].map(makeLi)
				);
				return html`
					<h2>Node Array Tests</h2>
					<input ${ref(el => inputEl = el)} placeholder=">Enter what you want to add to the array here<" type="text"><br>
					${['unshift', 'shift', 'push', 'pop'].map(op => 
						html`<button ${on('click', _ => {
								console.groupCollapsed(op);
								listItems.array[op](
									makeLi(inputEl.value)
								);
								console.groupEnd();
							})}>
								${op}
							</button>`
					)}<pre><ul>${listItems}</ul></pre>
				`
			})(),
			dial(),
			(function() {
				return html`
					<h2>Test Swapping</h2>
					${(async function*() {
						function shouldSwap(txt) {
							return html`<b>Should Swap:</b>${txt}`;
						}
						while(1) {
							yield shouldSwap('1');
							await delay(1000);
							yield shouldSwap('2');
							await delay(1000);
							yield html`<i>Shouldn't Swap</i>`;
							await delay(1000);
						}
					})()}
				`;
			})(),
			(function(){
				const address = new LiveData();
				address.value = 0;
				async function* ag_map(iteration, func) {
					for await(const val of iteration) {
						yield func(val);
					}
				}
				function split(iteration, initial) {
					const ld = new LiveData();
					ld.value = initial;
					(async () => {
						// Run
						for await(const value of iteration) {
							ld.value = value;
						}
					})();
					return ld;
				}
				const binary = split(ag_map(address, a => a.toString(2).padStart(32, '0')), '0'.repeat(32));
				const tag = split(ag_map(binary, b => b.slice(0, 21)));
				const index = split(ag_map(binary, b => b.slice(21, 26)), '0'.repeat(5));
				const offset = split(ag_map(binary, b => b.slice(26)));
				return html`
					<input type="number" ${on('input', e => address.value = e.target.valueAsNumber || 0)}><br>
					Binary: 
						<span style="color: red;">${tag}(${ag_map(tag, n => Number.parseInt(n, 2))})</span>
						<span style="color: green;">${index}(${ag_map(index, n => Number.parseInt(n, 2))})</span>
						<span style="color: blue;">${offset}(${ag_map(offset, n => Number.parseInt(n, 2))})</span><br>
					Block Address: ${ag_map(address, a => Math.floor(a / 128))}<br>
					Block's First Byte Address: ${ag_map(address, a => {
						const fb = a & ~0b111111
						return `${fb.toString(2).padStart(32, '0')}(${fb})`;
					})}<br>
					Block ID in Cache: ${ag_map(address, a => Math.floor(a / 128) % 32)}
				`;
			})(),
			(function(){
				const color = new LiveData();
				color.value = 'black';
				return html`
				<h2 class="testing-css">Test Modifying CSS using the css tag</h2>
				${css`h2.testing-css { 
					color: ${color};
				}`}
				${[
					'Red', 'Cornsilk', 'Black', 'Navy', 'Teal', 'RebeccaPurple'
				].map(val => html`
					<button ${on('click', _ => color.value = val.toLowerCase())}>
						${val}
					</button>`
				)}
				`;
			})(),
			(function(){
				const radius = new LiveData();
				radius.value = 50;
				return html`
				<h2>Test modifying SVG attribute</h2>
				<svg viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
  					<circle cx="50" cy="50" r="${radius}"/>
				</svg>
				<input type="range" 
					value="${radius.value}" 
					min="10" max="70" step="1" 
					${on('input', e => radius.value = e.target.valueAsNumber)}
				/>
				`;
			})(),
//			/*
			// Simple Test with Comment node
			html`
				<section class="${"a"} mixed with ${"b"} other things">
					<header ${ref(el => el)}>
						<h1>${"Text Location"}</h1>
					</header>
					<!-- Test user comments: } not; JSON' { -->
				</section>
			`,

			// Test if the marker get's lost when it's value doesn't match the attribute
			html`
				<form action="" method="">
					<select>
						<option selected="before ${''} after">Guts of an option</option>
					</select>
				</form>
			`,


			// Sample with event handlers
			(function(){
				const count = new LiveData();
				count.value = 10;
				return html`
					<button ${on('click', () => count.value -= 1)}>-</button>
					${count}
					<button ${on('click', () => count.value += 1)}>+</button>
				`;
			})(),

			// Troubleshooting a bug
			html`${'another'} ${'hello'}`,

//			*/
			
			// Test for using multiple templates swapped by async generator as a state machine
			html`${(async function*() {
				const count = new LiveData();
				count.value = 10;
				yield html`First: Set the count to 25...<br />
					${html`
					<button ${on('click', () => count.value -= 1)}>-</button>
					${count}
					<button ${on('click', () => count.value += 1)}>+</button>
				`}`;
				for await(const val of count) {
					if (val == 25) break;
				}
				count.value = 0;
				yield html`
					Next: Set the thingy to 5<br />
					<label>
						${count}
						<input type="range" 
							value="${count.value}" 
							min="0" max="10" step="1" 
							${on('input', e => count.value = e.target.valueAsNumber)}
						/>
					</label>
				`;
				for await(const val of count) {
					if (val == 5) break;
				}
				yield `Good Job ðŸŽ‰  Thank you for following along`;
			})()}`

		];
		performance.mark('start-test-rendering');
		for (const test of tests) {
			const instanceContainer = document.createElement('div');
			instanceContainer.classList.add('instance');
			// So... I would normally try and build the dom and then append it but to have style parts work correctly, I have to append and then bind which will mean that some changes will happen after the element has been placed into the dom.  Honestly, I've always done it because I assumed it would have better performance but I've never tried it so it would be worth a performance test.
			document.body.append(instanceContainer);
			mount(test, instanceContainer);
		}
		performance.measure('render-time');
		const [renderEntry] = performance.getEntriesByName('render-time')
		console.log(renderEntry.duration);
	</script>
	<script type="_application/ECMAScript" async defer>
		function delay(ms) {
			return new Promise(resolve => setTimeout(resolve, ms));
		}
		function* testHelper() {
			console.log('Entering Helper');
			yield delay(1000); // State H-1
			console.log('Helper: Transition 1');
			yield delay(1000); // State H-2
			console.log('Helper: Transition 2');
			return 5;
		}
		function* test() {
			try {
				console.log('About to call testHelper');
				const value = yield* testHelper();
				console.log(`Got ${value} from testHelper`);
			} finally {
				console.log('starting the finally');
				yield delay(1000);
				console.log('finishing the finally');
			}
			return 'success';
		}
		const a = cancelable(test());
		a.then(result => console.log('cancelable resolved with', result));


function cancelable(instance) {
	const result = (async () => {
		let step = instance.next();
		while(1) {
			const {value, done} = step;
			if (done) {
				return value;
			} else {
				try {
					const result = await value;
					step = instance.next(result);
				} catch(err) {
					step = instance.throw(err);
				}
			}
		}
	})();
	result.cancel = () => instance.return();
	return result;
}
	</script>
	<script type="_application/ECMAScript" async defer>
		function* some() {
			try {
				yield 1;
				yield 2;
				yield 3;
			} finally {
				yield 4;
				return 5;
			}
		}
		function* another() {
			yield 'First';
			const getFromOther = yield* some();
			yield `Got ${getFromOther} from some`;
			return 'finally';
		}
	</script>
	<script type="_application/ECMAScript" async defer>
		const i1 = {num: 1};
		const i2 = {num: 2};
		const i3 = {num: 3};
		const i4 = {num: 4};
		const i5 = {num: 5};
		const i6 = {num: 6};
		const arr = [i1, i2, i3, i4];
		arr.unshift(i5);
		console.log(arr); // Expecting: [i5, i1, i2, i3, i4]
		const proxy = new Proxy(arr, {
			set(target, key, newValue) {
				console.log('Setting ', key, ' from ', target[key], ' to ', newValue);
				const num = Number.parseInt(key);
				if (!isNaN(num) && num >= 0) {
					const oldIndex = target.indexOf(newValue);
					if (oldIndex !== -1) {
						target[oldIndex] = undefined;
					}
					return target[key] = newValue;
				} else {
					return target[key] = newValue;
				}
			}
		});
		Array.prototype.unshift.call(proxy, i6);
		console.log(arr); // Expecting: [i6, i5, i1, i2, i3, i4]
	</script>
</body>
</html>