<!DOCTYPE html>
<html>
<head>
	<title>Tests for: js-min</title>
</head>
<body>
	<style>
		.template, .instance {
			border: black 1px solid;
			padding: 1em;
			margin: 1em;
		}
		.instance {
			border-color: #eee;
		}
	</style>
	<h1>These are tests for my JavaScript Framework</h1>
	<p>You can find out more about it at <a href="https://github.com/evan-brass/js-framework">https://github.com/evan-brass/js-framework</a> or view the code that generates these examples here: <a href="https://github.com/evan-brass/js-framework/blob/master/test.html">https://github.com/evan-brass/js-framework/blob/master/test.html</a></p>
	<script type="module" src="./src/tests/template.test.mjs"></script>
	<script type="module">
		import LiveData from './src/live-data.mjs';
		import {s, on, mount} from './src/expressions.mjs';
		import html from './src/min.mjs';
		import {ArrayInstance} from './src/instance.mjs';
		import delay from './src/delay.mjs';
		import dial from './src/tests/dial.mjs';
		const tests = [
			dial(),
			(function() {
				return html`
					<h2>Test Swapping</h2>
					${(async function*() {
						function shouldSwap(txt) {
							return html`<b>Should Swap:</b>${s(txt)}`;
						}
						while(1) {
							yield shouldSwap('1');
							await delay(1000);
							yield shouldSwap('2');
							await delay(1000);
							yield html`<i>Shouldn't Swap</i>`;
							await delay(1000);
						}
					})()}
				`;
			})(),
			(function(){
				const address = new LiveData();
				address.value = 0;
				async function* ag_map(iteration, func) {
					for await(const val of iteration) {
						yield func(val);
					}
				}
				function split(iteration, initial) {
					const ld = new LiveData();
					ld.value = initial;
					(async () => {
						// Run
						for await(const value of iteration) {
							ld.value = value;
						}
					})();
					return ld;
				}
				const binary = split(ag_map(address, a => a.toString(2).padStart(32, '0')), '0'.repeat(32));
				const tag = split(ag_map(binary, b => b.slice(0, 21)));
				const index = split(ag_map(binary, b => b.slice(21, 26)), '0'.repeat(5));
				const offset = split(ag_map(binary, b => b.slice(26)));
				return html`
					<input type="number" ${on('change', e => address.value = e.target.valueAsNumber)}><br>
					Binary: 
						<span style="color: red;">${tag}(${ag_map(tag, n => Number.parseInt(n, 2))})</span>
						<span style="color: green;">${index}(${ag_map(index, n => Number.parseInt(n, 2))})</span>
						<span style="color: blue;">${offset}(${ag_map(offset, n => Number.parseInt(n, 2))})</span><br>
					Block Address: ${ag_map(address, a => Math.floor(a / 128))}<br>
					Block's First Byte Address: ${ag_map(address, a => {
						const fb = a & ~0b111111
						return `${fb.toString(2).padStart(32, '0')}(${fb})`;
					})}<br>
					Block ID in Cache: ${ag_map(address, a => Math.floor(a / 128) % 32)}
				`;
			})(),
			(function(){
				const color = new LiveData();
				color.value = 'black';
				return html`
				<h2 class="testing-css">Test Modifying CSS using NodePart</h2>
				<style>.testing-css{ color: ${color}; }</style>
				${new ArrayInstance([
					'Red', 'Cornsilk', 'Black', 'Navy', 'Teal', 'RebeccaPurple'
				].map(val => html`<button ${on('click', _ => color.value = val.toLowerCase())}>${s(val)}</button>`))}
				`;
			})(),
			(function(){
				const radius = new LiveData();
				radius.value = 50;
				return html`
				<h2>Test modifying SVG attribute</h2>
				<svg viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
  					<circle cx="50" cy="50" r="${radius}"/>
				</svg>
				<input type="range" 
					value="${s(radius.value)}" 
					min="10" max="70" step="1" 
					${on('change', e => radius.value = e.target.valueAsNumber)}
				/>
				`;
			})(),
//			/*
			// Simple Test with Comment node
			html`
				<section class="${s("a")} mixed with ${s("b")} other things">
					<header ${s({class: "purple"})}>
						<h1>${s("Text Location")}</h1>
					</header>
					<!-- Test user comments: } not; JSON' { -->
				</section>
			`,

			// Test if the marker get's lost when it's value doesn't match the attribute
			html`
				<form action="" method="">
					<select>
						<option selected="before ${s('')} after">Guts of an option</option>
					</select>
				</form>
			`,


			// Sample with event handlers
			(function(){
				const count = new LiveData();
				count.value = 10;
				return html`
					<button ${on('click', () => count.value -= 1)}>-</button>
					${count}
					<button ${on('click', () => count.value += 1)}>+</button>
				`;
			})(),

			// Troubleshooting a bug
			html`${s('another')} ${s('hello')}`,

//			*/
			
			// Test for using multiple templates swapped by async generator as a state machine
			html`${(async function*() {
				const count = new LiveData();
				count.value = 10;
				yield html`First: Set the count to 25...<br />
					${s(html`
					<button ${on('click', () => count.value -= 1)}>-</button>
					${count}
					<button ${on('click', () => count.value += 1)}>+</button>
				`)}`;
				for await(const val of count) {
					if (val == 25) break;
				}
				count.value = 0;
				yield html`
					Next: Set the thingy to 5<br />
					<label>
						${count}
						<input type="range" 
							value="${s(count.value)}" 
							min="0" max="10" step="1" 
							${on('change', e => count.value = e.target.valueAsNumber)}
						/>
					</label>
				`;
				for await(const val of count) {
					if (val == 5) break;
				}
				yield `Good Job ðŸŽ‰  Thank you for following along`;
			})()}`

		];
		for (const test of tests) {
			const instanceContainer = document.createElement('div');
			instanceContainer.classList.add('instance');
			mount(test, instanceContainer);
			document.body.append(instanceContainer);
		}
	</script>
	<script type="module">
		import ObservableArray from './src/observable-array.mjs';

		const arr = new ObservableArray();
		const {wait, added, removed, moved, proxy} = arr;
		function clear (){
			console.log(proxy.toString());
			console.log(`${added.size} Added; ${removed.size} Removed; ${moved.size} Moved`);
			added.clear();
			removed.clear();
			moved.clear();
		}

		proxy.push(3);
		proxy.push(2);
		proxy.push(1);

		console.log('3 pushes'); clear();

		proxy.pop();

		console.log('1 pop'); clear();

		proxy.splice(1, 0, 17, 12, 34, 9, 5);

		console.log('splice'); clear();

		proxy.sort();

		console.log('sort'); clear();
		/*
		const arr = new Proxy([1,2,3,4,5,6,7,8,9,10], {
			get(target, name) {
				console.log('get', name);
				return target[name];
			},
			set(target, name, value) {
				console.log('set', name, value);
				return target[name] = value;
			}
		});
		console.group('reverse');
		Array.prototype.reverse.call(arr);
		console.groupEnd();
		
		console.group('sort');
		Array.prototype.sort.call(arr, (a, b) => a - b);
		console.groupEnd();
		*/
	</script>
</body>
</html>