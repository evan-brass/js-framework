<!DOCTYPE html>
<html>
<head>
	<title>Tests for: js-min</title>
	<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
	<!--
	<style>
		.template, .instance {
			border: black 1px solid;
			padding: 1em;
			margin: 1em;
		}
		.instance {
			border-color: #eee;
		}
	</style>
	<h1>These are tests for my JavaScript Framework</h1>
	<p>You can find out more about it at <a href="https://github.com/evan-brass/js-framework">https://github.com/evan-brass/js-framework</a> or view the code that generates these examples here: <a href="https://github.com/evan-brass/js-framework/blob/master/test.html">https://github.com/evan-brass/js-framework/blob/master/test.html</a></p>
	-->
	<script type="module" src="./src/tests/manual/tests.mjs"></script>
	<script type="_application/ECMAScript" async defer>
		function delay(ms) {
			return new Promise(resolve => setTimeout(resolve, ms));
		}
		function* testHelper() {
			console.log('Entering Helper');
			yield delay(1000); // State H-1
			console.log('Helper: Transition 1');
			yield delay(1000); // State H-2
			console.log('Helper: Transition 2');
			return 5;
		}
		function* test() {
			try {
				console.log('About to call testHelper');
				const value = yield* testHelper();
				console.log(`Got ${value} from testHelper`);
			} finally {
				console.log('starting the finally');
				yield delay(1000);
				console.log('finishing the finally');
			}
			return 'success';
		}
		const a = cancelable(test());
		a.then(result => console.log('cancelable resolved with', result));


function cancelable(instance) {
	const result = (async () => {
		let step = instance.next();
		while(1) {
			const {value, done} = step;
			if (done) {
				return value;
			} else {
				try {
					const result = await value;
					step = instance.next(result);
				} catch(err) {
					step = instance.throw(err);
				}
			}
		}
	})();
	result.cancel = () => instance.return();
	return result;
}
	</script>
	<script type="_application/ECMAScript" async defer>
		function* some() {
			try {
				yield 1;
				yield 2;
				yield 3;
			} finally {
				yield 4;
				return 5;
			}
		}
		function* another() {
			yield 'First';
			const getFromOther = yield* some();
			yield `Got ${getFromOther} from some`;
			return 'finally';
		}
	</script>
	<script type="_application/ECMAScript" async defer>
		const i1 = {num: 1};
		const i2 = {num: 2};
		const i3 = {num: 3};
		const i4 = {num: 4};
		const i5 = {num: 5};
		const i6 = {num: 6};
		const arr = [i1, i2, i3, i4];
		arr.unshift(i5);
		console.log(arr); // Expecting: [i5, i1, i2, i3, i4]
		const proxy = new Proxy(arr, {
			set(target, key, newValue) {
				console.log('Setting ', key, ' from ', target[key], ' to ', newValue);
				const num = Number.parseInt(key);
				if (!isNaN(num) && num >= 0) {
					const oldIndex = target.indexOf(newValue);
					if (oldIndex !== -1) {
						target[oldIndex] = undefined;
					}
					return target[key] = newValue;
				} else {
					return target[key] = newValue;
				}
			}
		});
		Array.prototype.unshift.call(proxy, i6);
		console.log(arr); // Expecting: [i6, i5, i1, i2, i3, i4]
	</script>
</body>
</html>