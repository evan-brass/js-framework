<!DOCTYPE html>
<html>
<head>
	<title>Tests for: js-min</title>
	<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
	<style>
		.template, .instance {
			border: black 1px solid;
			padding: 1em;
			margin: 1em;
		}
		.instance {
			border-color: #eee;
		}
	</style>
	<h1>These are tests for my JavaScript Framework</h1>
	<p>You can find out more about it at <a href="https://github.com/evan-brass/js-framework">https://github.com/evan-brass/js-framework</a> or view the code that generates these examples here: <a href="https://github.com/evan-brass/js-framework/blob/master/test.html">https://github.com/evan-brass/js-framework/blob/master/test.html</a></p>
	<script type="_module">
		import LiveData from './src/lib/live-data.mjs';
		import on from './src/users/on.mjs';
		import constant from './src/users/constant.mjs';
		import mount from './src/mount.mjs';
		import html from './src/html.mjs';
		import ArrayInstance from './src/users/array-instance.mjs';
		import delay from './src/lib/delay.mjs';
		import dial from './src/tests/dial.mjs';
		const tests = [
			dial(),
			(function() {
				return html`
					<h2>Test Swapping</h2>
					${(async function*() {
						function shouldSwap(txt) {
							return html`<b>Should Swap:</b>${txt}`;
						}
						while(1) {
							yield shouldSwap('1');
							await delay(1000);
							yield shouldSwap('2');
							await delay(1000);
							yield html`<i>Shouldn't Swap</i>`;
							await delay(1000);
						}
					})()}
				`;
			})(),
			(function(){
				const address = new LiveData();
				address.value = 0;
				async function* ag_map(iteration, func) {
					for await(const val of iteration) {
						yield func(val);
					}
				}
				function split(iteration, initial) {
					const ld = new LiveData();
					ld.value = initial;
					(async () => {
						// Run
						for await(const value of iteration) {
							ld.value = value;
						}
					})();
					return ld;
				}
				const binary = split(ag_map(address, a => a.toString(2).padStart(32, '0')), '0'.repeat(32));
				const tag = split(ag_map(binary, b => b.slice(0, 21)));
				const index = split(ag_map(binary, b => b.slice(21, 26)), '0'.repeat(5));
				const offset = split(ag_map(binary, b => b.slice(26)));
				return html`
					<input type="number" ${on('input', e => address.value = e.target.valueAsNumber || 0)}><br>
					Binary: 
						<span style="color: red;">${tag}(${ag_map(tag, n => Number.parseInt(n, 2))})</span>
						<span style="color: green;">${index}(${ag_map(index, n => Number.parseInt(n, 2))})</span>
						<span style="color: blue;">${offset}(${ag_map(offset, n => Number.parseInt(n, 2))})</span><br>
					Block Address: ${ag_map(address, a => Math.floor(a / 128))}<br>
					Block's First Byte Address: ${ag_map(address, a => {
						const fb = a & ~0b111111
						return `${fb.toString(2).padStart(32, '0')}(${fb})`;
					})}<br>
					Block ID in Cache: ${ag_map(address, a => Math.floor(a / 128) % 32)}
				`;
			})(),
			/* No Longer works... I either need a stylesheet part (could be simple text replacement) or something else.  Due to the stylesheet constructor, anything I would do without the stylesheet constructor would be poor design later on so I'd rather wait.  If I did a syle part then I'd want to make it so that added and removed it's stylesheet from .getRootNode().adoptedStylesheets
			(function(){
				const color = new LiveData();
				color.value = 'black';
				return html`
				<h2 class="testing-css">Test Modifying CSS using NodePart</h2>
				<style>.testing-css{ color: ${color}; }</style>
				${new ArrayInstance([
					'Red', 'Cornsilk', 'Black', 'Navy', 'Teal', 'RebeccaPurple'
				].map(val => html`<button ${on('click', _ => color.value = val.toLowerCase())}>${val)}</button>`))}
				`;
			})(),
			*/
			(function(){
				const radius = new LiveData();
				radius.value = 50;
				return html`
				<h2>Test modifying SVG attribute</h2>
				<svg viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
  					<circle cx="50" cy="50" r="${radius}"/>
				</svg>
				<input type="range" 
					value="${radius.value}" 
					min="10" max="70" step="1" 
					${on('input', e => radius.value = e.target.valueAsNumber)}
				/>
				`;
			})(),
//			/*
			// Simple Test with Comment node
			html`
				<section class="${"a"} mixed with ${"b"} other things">
					<header ${{class: "purple"}}>
						<h1>${"Text Location"}</h1>
					</header>
					<!-- Test user comments: } not; JSON' { -->
				</section>
			`,

			// Test if the marker get's lost when it's value doesn't match the attribute
			html`
				<form action="" method="">
					<select>
						<option selected="before ${''} after">Guts of an option</option>
					</select>
				</form>
			`,


			// Sample with event handlers
			(function(){
				const count = new LiveData();
				count.value = 10;
				return html`
					<button ${on('click', () => count.value -= 1)}>-</button>
					${count}
					<button ${on('click', () => count.value += 1)}>+</button>
				`;
			})(),

			// Troubleshooting a bug
			html`${'another'} ${'hello'}`,

//			*/
			
			// Test for using multiple templates swapped by async generator as a state machine
			html`${(async function*() {
				const count = new LiveData();
				count.value = 10;
				yield html`First: Set the count to 25...<br />
					${html`
					<button ${on('click', () => count.value -= 1)}>-</button>
					${count}
					<button ${on('click', () => count.value += 1)}>+</button>
				`}`;
				for await(const val of count) {
					if (val == 25) break;
				}
				count.value = 0;
				yield html`
					Next: Set the thingy to 5<br />
					<label>
						${count}
						<input type="range" 
							value="${count.value}" 
							min="0" max="10" step="1" 
							${on('input', e => count.value = e.target.valueAsNumber)}
						/>
					</label>
				`;
				for await(const val of count) {
					if (val == 5) break;
				}
				yield `Good Job ðŸŽ‰  Thank you for following along`;
			})()}`

		];
		performance.mark('start-test-rendering');
		for (const test of tests) {
			const instanceContainer = document.createElement('div');
			instanceContainer.classList.add('instance');
			mount(test, instanceContainer);
			document.body.append(instanceContainer);
		}
		performance.measure('render-time');
		const [renderEntry] = performance.getEntriesByName('render-time')
		console.log(renderEntry.duration);
	</script>
	<script type="application/ECMAScript" async defer>
		function delay(ms) {
			return new Promise(resolve => setTimeout(resolve, ms));
		}
		function* testHelper() {
			console.log('Entering Helper');
			yield delay(1000); // State H-1
			console.log('Helper: Transition 1');
			yield delay(1000); // State H-2
			console.log('Helper: Transition 2');
			return 5;
		}
		function* test() {
			try {
				console.log('About to call testHelper');
				const value = yield* testHelper();
				console.log(`Got ${value} from testHelper`);
			} finally {
				console.log('starting the finally');
				yield delay(1000);
				console.log('finishing the finally');
			}
			return 'success';
		}
		const a = cancelable(test());
		a.then(result => console.log('cancelable resolved with', result));


function cancelable(instance) {
	const result = (async () => {
		let step = instance.next();
		while(1) {
			const {value, done} = step;
			if (done) {
				return value;
			} else {
				try {
					const result = await value;
					step = instance.next(result);
				} catch(err) {
					step = instance.throw(err);
				}
			}
		}
	})();
	result.cancel = () => instance.return();
	return result;
}
	</script>
	<script type="application/ECMAScript" async defer>
		function* some() {
			try {
				yield 1;
				yield 2;
				yield 3;
			} finally {
				yield 4;
				return 5;
			}
		}
		function* another() {
			yield 'First';
			const getFromOther = yield* some();
			yield `Got ${getFromOther} from some`;
			return 'finally';
		}
	</script>
</body>
</html>